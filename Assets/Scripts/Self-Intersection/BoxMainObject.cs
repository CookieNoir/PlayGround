using UnityEngine;

class MainBoxes
{
    public Vector3 pos;
    public Vector3 size;
    public Quaternion q;

    public MainBoxes(GameObject kub)
    {
        pos = kub.transform.position;
        size = kub.transform.lossyScale;
        q = kub.transform.rotation;
    }

    public void upd(GameObject baseObj)
    {

        pos = baseObj.transform.position;
        q = baseObj.transform.rotation;
        pos = baseObj.transform.position + (pos - baseObj.transform.position);

        /*
        pos += -baseObj.transform.position;
        pos = BoxCollision.QuanRotation(pos, q);
        pos += baseObj.transform.position;*/
    }

}
public class BoxMainObject : MonoBehaviour
{
    public GameObject[] robot = new GameObject[15];
    //комментариями помечена диагональ, что бы удобней читалось

    private static byte[,] matrixCross = new byte[15, 15];
    //                     0   1  2  3  4  5  6  7  8  9 
    //{   /*0 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1}, 
    ///*1 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1}, 
    // /*2 лапа1*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},  
    //  /*3 лапа2*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},  
    //  /*4 лапа3*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},  
    //  /*5 лапа4*/        {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1}, 
    // /*6 осн. стрелы*/  {0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1},  
    ///*7 стрела1*/      {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1}, 
    // /*8 стрела2*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1}, 
    // /*9 стрела3*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1}, 
    ///*A удлинение*/    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},  
    //  /*B конец*/        {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
    // /*С навесное*/     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}, 
    //   /*D навесное*/     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}, 
    //  /*E навесное*/     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0}, 

    // };

    private static byte[,] matrixCrossEmpty = 
        //                     0   1  2  3  4  5  6  7  8  9 
        {   /*0 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1}, 
            /*1 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1}, 
            /*2 лапа1*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},  
            /*3 лапа2*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},  
            /*4 лапа3*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1},  
            /*5 лапа4*/        {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1}, 
            /*6 осн. стрелы*/  {0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1},  
            /*7 стрела1*/      {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1}, 
            /*8 стрела2*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1}, 
            /*9 стрела3*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1}, 
            /*A удлинение*/    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},  
            /*B конец*/        {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*С навесное*/     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*D навесное*/     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*E куб*/          {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
        };

    private static byte[,] matrixCrossGrab = 
        //                     0   1  2  3  4  5  6  7  8  9 
        {   /*0 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1}, 
            /*1 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1}, 
            /*2 лапа1*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1},  
            /*3 лапа2*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1},  
            /*4 лапа3*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1},  
            /*5 лапа4*/        {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1}, 
            /*6 осн. стрелы*/  {0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1},  
            /*7 стрела1*/      {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1}, 
            /*8 стрела2*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1}, 
            /*9 стрела3*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1}, 
            /*A удлинение*/    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},  
            /*B конец*/        {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*С навесное*/     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*D навесное*/     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}, 
            /*F куб*/          {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},

        };

    private static byte[,] matrixCrossHydro = 
        //                     0   1  2  3  4  5  6  7  8  9 
        {   /*0 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1}, 
            /*1 корпус*/       {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1}, 
            /*2 лапа1*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1},  
            /*3 лапа2*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1},  
            /*4 лапа3*/        {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1},  
            /*5 лапа4*/        {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1}, 
            /*6 осн. стрелы*/  {0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1},  
            /*7 стрела1*/      {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1}, 
            /*8 стрела2*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1}, 
            /*9 стрела3*/      {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1}, 
            /*A удлинение*/    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1},  
            /*B конец*/        {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*С навесное*/     {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}, 
            /*D навесное*/     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            /*E куб*/          {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
        };

    public void SetLast(GameObject box)
    {
        robot[robot.Length - 1] = box;
    }

    public void SetMatrixType(Accessory accessory)
    {
        if (accessory)
        {
            System.Type type = accessory.GetType();
            if (type == typeof(Grab))
                matrixCross = matrixCrossGrab;
            else if (type == typeof(HydraulicHammer))
                matrixCross = matrixCrossHydro;
            Debug.Log(type);
        }
        else matrixCross = matrixCrossEmpty;
    }

    public bool DetectAllCollission()
    {
        for (int i = 0; i < robot.Length; i++)
        {
            for (int j = 0; j < robot.Length; j++)
            {
                if (matrixCross[i, j] == 1)
                {
                    //проверяем
                    Vector3 result = BoxCollision.Collision(robot[i], robot[j]);
                    if (result != Vector3.zero)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }
}